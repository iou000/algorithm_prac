#반올림 (실수, 반올림하고자하는 위치 -1) / 두번째 인자 없을시 첫째자리에서 반올림
round(123.456, 2)
# ==> 123.46


#리스트 슬라이싱
a = [1,2,3,4,5,6,7,8]
print(a[1:4])
# ==> [2,3,4]


#리스트 컴프리헨션
#0~19 홀수만 포함하는 리스트
array = [i for i in range(20) if i%2 == 1]
# ==> [1,3,5,7,9,11,13,15,17,19]
# 1~9 수의 제곱 값을포함하는 리스트
array = [i*i for i in range(10)]
# ==> [1,4,9,16,25,36,49,68,81]


#2차원 리스트 초기화 : 리스트 컴프리헨션
#N x M 크기의 2차원 리스트 초기화
#특정 크기의 2차원 리스트를 초기화 할 땐 반드시 리스트 컴프리헨션 이용
n = 3
m = 4
array = [[0]*m for _ in range(n)]
#
#  _ 의 역할 : 반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할 때 사용


# -----------리스트 관련 기타 메소드------------
a=[1,4,3]

#리스트 맨 끝에 원소 하나 삽입
a.append(2)  # O(1)
# ==> a == [1,4,3,2] 

#오름차순으로 정렬 O(N)
a.sort()
a.sort(reverse = True) #내림차순 #O(NlogN)
# ==> a == [1,2,3,4] / a == [4,3,2,1]

#리스트 뒤집기
a.reverse() #O(N)
# ==> a == [1,2,3,4]

#특정 위치에 원소 삽입
#중간에 원소삽입 후 리스트의 원소 위치조정
a.insert(2,3) #O(N)
# ==> a ==[1,2,3,3,4]

#특정 값을 가지는 데이터 개수
a.count(3) #O(N)
# ==> 2

#특정 값 데이터 삭제
#중간에 원소삭제 후 리스트의 원소 위치조정
a.remove(1) #O(N)
# ==> a == [2,3,3,4]

# 파이썬에서 특정 값을 가진 원소 모두 삭제 [remove_all] 하는 법
a = [1,2,3,4,5,5,5]
remove_set = {3,5}
#remove_set에 포함되지 않은 값만을 저장
result = [i for i in a if i not in remove_set]
# ==> result == [1,2,4]


#----------------- 문자열 ----------------
#파이썬의 문자열은 내부적으로 리스트와 같이 처리됨. -> 슬라이싱, 인덱싱 가능.


#----------------- 튜플 -----------------
# 한 번 선언된 값은 변경 불가.
# () 사용
# 그래프 알고리즘 구현때 자주 사용됨.
# 다익스트라의 경우 내부에서 우선순위 큐를 사용하는데 해당 알고리즘에서 우선순위 큐에 들어간 값은 변경x
# 따라서 우선순위 큐에 들어가는 데이터를 튜플로 구성.
# '비용' ,'노드번호'라는 서로 다른 성질의 데이터를 (비용,노드 번호)형태로 튜플로 묶어서 관리하는 것이 관례.
a = (1,2,3,4)
# ==> a == (1,2,3,4)


#----------------- 사전 자료형 -------------------
# 키, 값 의 쌍을 데이터로 가지는 자료형
# 내부적으로 '해시 테이블'을 이용하므로 기본적으로 데이터 검색 및 수정에 있어서 O(1)의 시간에 처리 가능.
# 따라서 키-값 쌍으로 구성된 데이터를 리스트보다 훨씬 빠르게 처리함.
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'
# ==> data == {'사과': 'Apple', '바나나': 'Banana', '코코넛': 'Coconut'}

# 사전 자료형 관련 함수
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'

#키 데이터만 담은 리스트
key_list = data.keys()
#값 데이터만 담은 리스트
value_list = data.values()
# ==> key_list == dict_keys(['사과', '바나나', '코코넛'])
# ==> value_list == dict_values(['Apple', 'Banana', 'Coconut'])

#각 키에 따른 값을 하나씩 출력
for key in key_list:
    print(data[key])
# ==> Apple
# ==> Banana
# ==> Coconut

#---------------- 집합 자료형 ----------------
# 리스트 or 문자열을 이용해 만들 수 있음.
# 중복x, 순서x -> 인덱싱x
# 키값 존재x, 데이터만 갖음.
# 특정 원소가 존재하는지 검사하는 연산의 시간복잡도 : O(1)
# '특정한 데이터가 이미 등장한 적이 있는지 여부'를 체크할 때 매우 효과적임.

#집합 자료형 초기화 방법 1
data = set([1,1,2,3,4,4,5])
# ==> data == {1,2,3,4,5}

#집합 자료형 초기화 방법 2
data = {1,1,2,3,4,4,5}
# ==> data == {1,2,3,4,5}

#집합 자료형의 연산
a = set([1,2,3,4,5])
b = set([3,4,5,6,7])

print(a | b) #합집합 {1,2,3,4,5,6,7}
print(a & b) #교집합 {3,4,5}
print(a - b) # 차집합 {1,2}

# 집합 자료형 관련 함수
data = set([1,2,3])

#새로운 원소 추가
data.add(4)
print(data) # {1,2,3,4}

#새로운 원소 여러 개 추가
data.update([5,6])
print(data) # {1,2,3,4,5,6}

#특정 값을 갖는 원소 삭제
data.remove(3)
print(data) #{1,2,4,5,6}

#---------------- 조건문 ------------------
# if 조건문 1:
#     조건문 1이 True일 때 실행되는 코드
# elif 조건문 2:
#     조건문 1에 해당하지 않고, 조건문 2가 True일 때 실행되는 코드
# else:
#     위의 모든 조건문이 True 값이 아닐 때 실행되는 코드


#---------------- 비교 연산자 ----------------
# X == Y : 서로 같을 때 True
# X != Y : 서로 다를 때 True
# X > Y, X < Y, X >= Y, X <= Y    알지..?


#---------------- 논리 연산자 ----------------
# X and Y : 둘다 참일때 True
# X or Y : 둘 중 하나만 참이어도 True
# not X  : X가 거짓일 때 True


#---------------- 파이썬 기타 연산자 ----------------
# X in 리스트 : 리스트 안에 X가 들어있을 때 참.
# X not in 문자열 : 문자열 안에 X가 들어있지 않으면 True
# pass : 조건문이 참이어도 아무것도 처리하고 싶지 않을 때

# if문 한줄로 작성
score = 85
#1.
if score >= 80: result = "Success"
#2. 조건부 표현식
result = "Success" if score >= 80 else "Fail"

# 조건부 표현식으로 리스트에서 특정한 원소의 값을 없애는 코드
a = [1,2,3,4,5,5,5]
remove_set= {3,5}
result = [i for i in a if i not in remove_set]

#파이썬에서는 수학 부등식 그대로 사용가능
x = 15
if 0< x < 20:
    print("x는 0초과 20미만의 수 입니다.") # x는 0초과 20미만의 수 입니다.
#근데 다른언어쓸 떄 헷갈릴 수 있으니까  x>0 and x<20 으로 사용.


#---------------- 반복문 ------------------
# for문과 while문이 있음. 둘중 뭘 써도 좋다~


# ------while문------
# 조건문이 참일 때에 한해서 반복적으로 코드 실행.
# while 조건:
#     소스코드

#------ for문------
# in 뒤에 오는 데이터에 포함된 모든 원소를 첫 번째 인덱스부터 차례대로 하나씩 방문함.
# for 변수 in 리스트:
#     소스코드

#수를 차례대로 나열할때 : range()
# for 변수 in range(시작 값, 끝 값 + 1):
#     소스코드

# continue
# 반복문 안에서 continue를 만나면 반복문의 처음으로 돌아감. (무시하고 다음 번호부터 처리)

# 2중 반복문
# 중첩 반복문은 '플로이드 워셜 알고리즘', '다이나믹 프로그래밍'등의 알고리즘 문제에서 매우 많이 사용됨.


#---------------- 함수 ------------------
# 동일한 알고리즘을 반복적으로 수행해야 할 때 중요하게 사용됨.
# def 함수명(매개변수):
#     소스코드
#     return 반환 값

# 함수 안에서 밖의 변수 데이터를 변경해야 하는 경우 : global 키워드 사용.
# global 키워드로 변수를 지정하면 지역변수를 만들지 않고, 함수 바깥에 사용된 변수를 바로 참조함.


#---------------- 람다 표현식 ------------------
#정렬 라이브러리를 사용할 때, 정렬 기준(key)을 설정할 때에도 자주 사용됨.
#람다식은 일회용이라 한번쓰고 버림.

#def add(a,b):
#     return a + b
#print(add(3,7))  #10

# ---- 람다식으로 구현한 add() 메서드 ----
#print((lambda a, b: a+b)(3, 7))